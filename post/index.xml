<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on filipecn</title>
    <link>/post/</link>
    <description>Recent content in Posts on filipecn</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 02 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>A path tracer with CUDA - prt 4</title>
      <link>/post/ptracer-gpu4/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/ptracer-gpu4/</guid>
      <description>What we have so far:
 Polymorphism is now forbidden! Instead, we store a pointer to the child object and cast properly before access (part 3) In practice, I&amp;rsquo;ll be casting objects with macros  Relations between classes In PBRT you have a class Shape that is inherited by classes such as Sphere and Cylinder. A Shape child stores the geometric information for a particular shape &amp;ndash; vertices, faces, position, scale, etc.</description>
    </item>
    
    <item>
      <title>GPU/CPU Memory Stack Allocator</title>
      <link>/post/gpu_memory_allocator/</link>
      <pubDate>Fri, 01 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/gpu_memory_allocator/</guid>
      <description>In this post I&amp;rsquo;ll experiment an idea to keep pointers of a memory block between CPU and GPU. The motivation here is to allow ourselves to allocate memory and instantiate objects on CPU side and be able to use their memory addresses in GPU.
Of course addresses change after we copy our data to the GPU! But I want to use a very basic idea: store memory address offsets instead of actual memory addresses.</description>
    </item>
    
    <item>
      <title>vtables vs switches</title>
      <link>/post/vtables-vs-switches/</link>
      <pubDate>Tue, 07 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/vtables-vs-switches/</guid>
      <description>Imagine this: you have a super class Letter and the whole alphabet of classes &amp;ndash; A, &amp;hellip;, Z &amp;ndash; that inherits from it. All children implement a method of Letter called spell that returns a char with the ascii of its respective letter. So, for instance, class A::spell() returns &#39;a&#39;.
Now you have an array with thousands of thousands of Letter children and you want to call spell for each of them &amp;ndash; the classic usage of polymorphism.</description>
    </item>
    
    <item>
      <title>A path tracer with CUDA - prt 3</title>
      <link>/post/ptracer-gpu3/</link>
      <pubDate>Sun, 05 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/ptracer-gpu3/</guid>
      <description>What we have so far:
 The image will be rendered in the GPU in groups of tiles. Each tile covers a sub-region of the image with 16x16 pixels. (part 1) A set of rays is generated for each pixel. Each ray direction is based on a random sample of the pixel&amp;rsquo;s area. We pre-compute and store all samples with a SamplePoll structure. (part 2)  The next topic is the way we will handle our objects (scene objects, materials, lights, etc&amp;hellip;).</description>
    </item>
    
    <item>
      <title>A path tracer with CUDA - prt 2</title>
      <link>/post/ptracer-gpu2/</link>
      <pubDate>Fri, 03 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/ptracer-gpu2/</guid>
      <description>In the last post I decide to follow the tile strategy. We want to process tiles of pixels in parallel. Each thread will handle a single tile by rendering all its pixels sequentially, then each tile will be indexed based on the thread&amp;rsquo;s grid position (CUDA):
// tile index hermes::index2 tile_index(threadIdx.x + blockIdx.x * blockDim.x, threadIdx.y + blockIdx.y * blockDim.y);  The first consequence here is that multiple tiles will dispute for the local memory in the streaming multi-processor.</description>
    </item>
    
    <item>
      <title>A path tracer with CUDA - prt 1</title>
      <link>/post/ptracer-gpu/</link>
      <pubDate>Sun, 04 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/ptracer-gpu/</guid>
      <description>This will be my next journey. I finally organized my self to get into the PBRT book. The idea for this project is to implement it (well.. at least part of it). Also, to make thinks even harder I decided to make use of the GPU. Hopefully, it will be my own version of PBRT in CUDA.
 Important note: this will be my learning exercise, not only about rendering but also about CUDA.</description>
    </item>
    
    <item>
      <title>Memory Dumps</title>
      <link>/post/memory_dumps/</link>
      <pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/memory_dumps/</guid>
      <description>I&amp;rsquo;ve been looking at memory dumps often lately. Since I usually (always) debug with &amp;lsquo;printf&amp;rsquo;, I needed a better visual for my memory dumps. I decided to do a simple memory dumper:
And added some features:
 Colored output Different data types (hex, decimal, &amp;hellip;) You can specify different regions with different colors and sub-regions Print actual data values Array elements alternate between bold and normal styles Display cache alignment  Here is a example:</description>
    </item>
    
    <item>
      <title>Scott Meyers&#39; Universal References</title>
      <link>/post/uref/</link>
      <pubDate>Thu, 27 May 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/uref/</guid>
      <description>I came across an another very clarifying talk of the legend Scott Meyers presenting Universal References in C++11 back in 2012. In this talk he calls our attention to the misleading usage of template parameters T&amp;amp;&amp;amp;, which we usually assume being rvalue references in all situations. It happens that it is not always the case.
The fact is that T&amp;amp;&amp;amp; becomes a rvalue reference or a lvalue reference depending on the case.</description>
    </item>
    
    <item>
      <title>devlog 1</title>
      <link>/post/devlog1/</link>
      <pubDate>Sat, 22 May 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/devlog1/</guid>
      <description>I decided to register my coding activities in this series of devlog blog posts.
Cubemap textures Now circe has some convenient functions to handle cubemap textures. Loading from separate files is easily done by
auto cubemap = circe::gl::Texture::fromFiles({ &amp;#34;.../skybox/right.jpg&amp;#34;, &amp;#34;.../skybox/left.jpg&amp;#34;, &amp;#34;.../skybox/top.jpg&amp;#34;, &amp;#34;.../skybox/bottom.jpg&amp;#34;, &amp;#34;.../skybox/front.jpg&amp;#34;, &amp;#34;.../skybox/back.jpg&amp;#34; }); A single file containing an equirectangular mapped texture, for example, can be loaded as a cubemap :
auto cubemap = circe::gl::Texture::fromFile(&amp;#34;.../image.hdr&amp;#34;, circe::texture_options::equirectangular | circe::texture_options::hdr, circe::texture_options::cubemap);  HDR textures are now supported as well.</description>
    </item>
    
    <item>
      <title>Interplay of Light</title>
      <link>/post/pbr-area-lights/</link>
      <pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/pbr-area-lights/</guid>
      <description>This text is just my personal notes on BRDFs. The text is heavily based on these references: real time rendering book, learn opengl website, Google&amp;rsquo;s Filament and here.
 Let&amp;rsquo;s consider light modeled as an electromagnetic wave (but treated as a ray when convenient), and our rendered image as the combination of all light that get into the camera sensors.
 An important property of light is the wavelength \(\lambda\), because it is related to the color of a particular light wave.</description>
    </item>
    
    <item>
      <title>Coordinate Systems and _their_ Projections</title>
      <link>/post/projections/</link>
      <pubDate>Thu, 01 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/projections/</guid>
      <description>The fundamental tool we use to render our virtual world from different points of view is the coordinate system. We can define a coordinate system for each model, for each light, for the camera, and one to arrange objects in the scene. Each of these coordinate systems define a coordinate space where we can compute position, orientation and size of our objects. We can also jump between different coordinate spaces. Each different space will fit best for each kind of situation.</description>
    </item>
    
    <item>
      <title>Hello Circe</title>
      <link>/post/2021-03-27-hello/</link>
      <pubDate>Sat, 27 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021-03-27-hello/</guid>
      <description>The Shader Storage Buffer Object (SSBO) and the Uniform Buffer Object (UBOs) are buffer objects in OpenGL used to transfer data to shaders. Although both are very similar there are important differences between them.
The UBO provides uniform data to the shader, in the form of uniform blocks, which is accessed through internal shader-accessible memory reads. The advantage of using the UBO instead of separate uniforms is that you can quickly switch between different sets of uniform data for different instances of the same program in you application.</description>
    </item>
    
    <item>
      <title>Object Pool</title>
      <link>/post/2021-03-13/</link>
      <pubDate>Sat, 13 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021-03-13/</guid>
      <description>Here is a simple and yet efficient object pool implementation.
 An object pool is a container that allows us to access, iterate, allocate, and destroy objects of a given type.
 A example of usage can be:
ObjectPool&amp;lt;Bubble&amp;gt; bubbles; // allocate two objects 	auto first_bubble = bubbles.allocate(); auto second_bubble = bubbles.allocate(); // remove one 	bubbles.free(first_bubble); // iteration 	for(const auto&amp;amp; bubble : bubles) // use bubble The key feature of the object pool structure is how it handles object deletion (and consequently, allocation).</description>
    </item>
    
    <item>
      <title>Convex polyhedra collision test (GJK Algorithm)</title>
      <link>/post/2019-07-26-gjk/</link>
      <pubDate>Fri, 26 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-07-26-gjk/</guid>
      <description>Let&amp;rsquo;s talk about a cool and efficient way make collision tests between (convex) polyhedra. The approach here though, is a little different from the usual geometric predicates, here we will use something called the Minkowski sum.
If we interpret a polyhedron as a set of points, two polyhedra represented by sets \(A\) and \(B\), for example, collide if \(A \cap B \neq \emptyset\). The intersection set \(A \cap B\) represents all pairs of points between \(A\) and \(B\) which have distance \(0\) between them, because well&amp;hellip; each of these pairs is composed by the same point (shared by \(A\) and \(B\)).</description>
    </item>
    
    <item>
      <title>Beautiful Bugs</title>
      <link>/post/2018-07-26-bug-art/</link>
      <pubDate>Thu, 26 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-07-26-bug-art/</guid>
      <description>Programming can be quite frustrating sometimes (if not most of the time), as we spend a great deal of time fixing errors and solving bugs. In graphics programming, bugs usually manifest visually and end up producing fun images of our struggle.
Here is a list of some of my numerous frustrating surprises that I certainly would not be able to reproduce consciously.
Streamlines Streamlines provide a cool way to visualize velocity fields and follow a simple idea: inject particles in the flow and track their path using line segments as time advances.</description>
    </item>
    
  </channel>
</rss>
