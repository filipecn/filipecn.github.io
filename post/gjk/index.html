<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Convex polyhedra collision test (GJK Algorithm) - Personal portfolio</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Filipe CN" />
  <meta name="description" content="If we interpret a polyhedron as a set of points, two polyhedra represented by sets \(A\) and \(B\), for example, collide if \(A \cap B \neq \emptyset\). The intersection set \(A \cap B\) represents all pairs of points between \(A\) and \(B\) which have distance \(0\) between them.
A very nice operation between sets of points is the Minkowski Sum:
Let \(A\) and \(B\) be two point sets. The Minkowski sum \(A \oplus B\) is defined as the set" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.36" />


<link rel="canonical" href="http://localhost:1313/post/gjk/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.0.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="Convex polyhedra collision test (GJK Algorithm)" />
<meta property="og:description" content="If we interpret a polyhedron as a set of points, two polyhedra represented by sets \(A\) and \(B\), for example, collide if \(A \cap B \neq \emptyset\). The intersection set \(A \cap B\) represents all pairs of points between \(A\) and \(B\) which have distance \(0\) between them.
A very nice operation between sets of points is the Minkowski Sum:
Let \(A\) and \(B\) be two point sets. The Minkowski sum \(A \oplus B\) is defined as the set" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/gjk/" />



<meta property="article:published_time" content="2016-10-21T15:43:48&#43;08:00"/>

<meta property="article:modified_time" content="2018-02-08T15:43:48&#43;08:00"/>











<meta itemprop="name" content="Convex polyhedra collision test (GJK Algorithm)">
<meta itemprop="description" content="If we interpret a polyhedron as a set of points, two polyhedra represented by sets \(A\) and \(B\), for example, collide if \(A \cap B \neq \emptyset\). The intersection set \(A \cap B\) represents all pairs of points between \(A\) and \(B\) which have distance \(0\) between them.
A very nice operation between sets of points is the Minkowski Sum:
Let \(A\) and \(B\) be two point sets. The Minkowski sum \(A \oplus B\) is defined as the set">


<meta itemprop="datePublished" content="2016-10-21T15:43:48&#43;08:00" />
<meta itemprop="dateModified" content="2016-10-21T15:43:48&#43;08:00" />
<meta itemprop="wordCount" content="1667">



<meta itemprop="keywords" content="geometry,programming,algorithm,hercules," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Convex polyhedra collision test (GJK Algorithm)"/>
<meta name="twitter:description" content="If we interpret a polyhedron as a set of points, two polyhedra represented by sets \(A\) and \(B\), for example, collide if \(A \cap B \neq \emptyset\). The intersection set \(A \cap B\) represents all pairs of points between \(A\) and \(B\) which have distance \(0\) between them.
A very nice operation between sets of points is the Minkowski Sum:
Let \(A\) and \(B\) be two point sets. The Minkowski sum \(A \oplus B\) is defined as the set"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<script src="http://localhost:1313//js/ie10-viewport-bug-workaround.js"></script>
<script src="http://localhost:1313//js/polygon.js"></script>
<script src="http://localhost:1313//js/two.min.js"></script>
<script src="https://api.trello.com/1/client.js?key=9c7b97c958253a327e9c117e960cf5aa"></script>

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">FilipeCN</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Blog</li>
      </a><a href="/research/">
        <li class="mobile-menu-item">Research</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">FilipeCN</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Blog</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/research/">Research</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Convex polyhedra collision test (GJK Algorithm)</h1>

      <div class="post-meta">
        <span class="post-time"> 2016-10-21 </span>
        <div class="post-category">
            
              <a href="/categories/english/"> English </a>
            
          </div>
        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#gilbert-johnson-keerthi-algorithm"><strong>Gilbert - Johnson - Keerthi Algorithm</strong></a>
<ul>
<li><a href="#carathéodory-s-theorem"><strong>Carathéodory&rsquo;s theorem</strong></a></li>
<li><a href="#first-step-k-1"><strong>first step</strong> \(k = 1\)</a></li>
<li><a href="#second-step-k-2"><strong>second step</strong> \(k = 2\)</a></li>
<li><a href="#n-th-step-k-n-n-2">\(n^{th}\) <strong>step</strong> \(k = n, n &gt; 2\)</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      

<p>If we interpret a polyhedron as a set of points, two polyhedra
represented by sets \(A\) and \(B\), for example, collide if \(A \cap B \neq \emptyset\).
The intersection set \(A \cap B\) represents all pairs of points
between \(A\) and \(B\) which have distance \(0\) between them.</p>

<p>A very nice operation between sets of points is the <strong>Minkowski Sum</strong>:</p>

<p><div class='block'>
  <p>Let \(A\) and \(B\) be two point sets. The Minkowski sum \(A \oplus B\) is defined as the set</p>

<p>$$A \oplus B = \{ a + b : a \in A, b \in B\}.$$
The <strong>Minkowski difference</strong> is obtained by \(A \ominus B = A \oplus (-B) \).</p>

</div>

The Minkowski sum is very useful because it can give us the distance between two sets of points \(A\) and \(B\):</p>

<p>$$distance(A, B) = min \{ \parallel c\parallel : c \in A \ominus B \}.$$</p>

<blockquote>
<p>The Euclidian distance between two polyhedra is equivalent to the distance between their Minkowski difference and the origin.</p>
</blockquote>

<p>For two convex polyhedra, \(A\) and \(B\), the Minkowski Sum \(C = A \oplus B\) has the following properties:</p>

<ul>
  <li>\(C\) is a convex polyhedron;</li>
  <li>The vertices of \(C\) are sums of vertices of \(A\) and \(B\).</li>
</ul>

<p>Thus, the collision exists if and only if \(C\) contains the origin. The red region bellow represents the Minkowski difference set of the two shapes,
play around with the vertices to visualize the final set, notice the origin point.</p>

<div id="myCanvas"></div>
<script src="../../js/draw2d.js" type="text/javascript"></script>
<div></div>

<h2 id="gilbert-johnson-keerthi-algorithm"><strong>Gilbert - Johnson - Keerthi Algorithm</strong></h2>

<p>In short, the GJK algorithm tests if two objects \(A\) and \(B\) are colliding by checking if \(0 \in A \ominus B\) is <strong>true</strong>
(simply \(distance(A, B)\)). Although it seems very straightforward (and it is indeed), the real magic and beauty of the GJK algorithm is how \(distance\) is
implemented. A very good description of the algorithm is given by <a href="https://www.youtube.com/watch?v=Qupqu1xe7Io">Casey Muratori</a>).</p>

<blockquote>
<p>The resulting Minkowski Sum of two convex polyhedra is also a convex polyhedron. Since all we care about is to check if \(0\) belongs to the final polyhedron, we only need to focus on the vertices of these geometric shapes, because any operation with interior points will lead to interior points of the resulting shape.</p>
</blockquote>

<p>The brute force algorithm would be to compute <strong>all</strong> pairs of vertices between the polyhedra, which leaves us with <strong>quadratic</strong> complexity.
In the GJK algorithm on the other hand, instead of computing the entire set \(C = A \ominus B\) explicitly, it only computes points necessary
to find the point in \(C\) that is closest to the origin. The GJK algorithm samples these points using a <strong>support mapping</strong> of \(C\).</p>

<div class='block'>
  <p>In short, a <strong>support mapping</strong> is a function that maps a given direction \(\vec{d}\) into a supporting point for the convex polyhedron \(A\).
  $$S_A(\vec{d}) = max \{ \vec{d^T}\cdot\vec{op}, p \in A \}.$$</p>

</div>


<p>In our 2D code, we could have something like this:</p>

<pre><code class="language-cpp">struct ConvexPolygon {
    vec2 support(vec2 d) {
      // for all vertices, find for which index the value of dot(vertices[i], d) is the gratest
      ...
      // instead of a O(n) algorithm here, we can use hill climbing search
      // in case our vertex list is topologically sorted
      return vertices[max_dot_i];
    }
    // suppose vertices form a convex shape
    std::vector&lt; vec2 &gt; vertices;
};
</code></pre>

<p>Since \(A \ominus B\) is a linear operation, we have</p>

<p>$$S_{A \ominus B}(\vec{d}) = max \{\vec{d^T}\cdot\vec{op}, p \in A \ominus B\}$$</p>

<p>$$= max \{ \vec{d^T}\cdot\vec{oa} - \vec{d^T}\cdot\vec{ob}, a \in A, b \in B \}$$</p>

<p>$$= max \{ \vec{d^T}\cdot\vec{oa}, a \in A \} - max \{ -\vec{d^T}\cdot\vec{ob}, b \in B \}$$</p>

<p>$$= S_A(\vec{d}) - S_B(-\vec{d})$$</p>

<p>It means that the <strong>support function</strong> of the Minkowski difference can be computed from the supporting points of the individual polyhedra \(A\) and \(B\).
Remember, the support function will help the algorithm to &ldquo;walk&rdquo; towards the origin, which is our point of interest, so we will choose the direction \(\vec{d}\) based on this goal. But how do we know the right direction to pick? This interesting theorem will help us answering this question:</p>

<h3 id="carathéodory-s-theorem"><strong>Carathéodory&rsquo;s theorem</strong></h3>

<div class='block'>
  <p>For a convex body \(H\) of \(\mathbb{R}^d\), each point of \(H\) can be expressed as the convex combination of no more than \(d + 1\) points from \(H\).</p>

</div>


<p>Ok, it didn&rsquo;t answered directly our question, but soon it is going to make sense. The message behind the theorem is that
each point of a polyhedron needs no more than 3 points of that polyhedron to be expressed,
in fact this sub-set of \(d + 1\) points has a name:</p>

<div class='block'>
  <p>Suppose \(d + 1\) points \(p_0, \dots, p_d \in \mathbb{R}^d \) are affinely independent, than the set of points
$$ S = \{ \theta_0 p_0 + \dots + \theta_d p_d \mid \theta_i \geq 0, 0 \leq i \leq d, \sum_0^d \theta_i = 1\}$$
is named <strong>d-Simplex</strong>. In other words, the simplex is the simplest polygon of its dimension, here are
the 0-Simplex, 1-Simplex, 2-Simplex and 3-Simplex respectively:</p>

<p><center><img align="middle" src="../../img/simplex.svg"   /></center></p>

</div>


<p>Since our Minkowski difference is a convex body it means that we can split it into a set of simplices and
search for the origin inside them.</p>

<p>However, we don&rsquo;t need do this explicitly, otherwise we would need to compute the Minkowski difference set explicitly too.
The strategy is to iteratively create a new simplex each step that contains points closer to the origin than the step before until
the origin happens to be inside of the current simplex or it be proved to be outside. We start with a 0-Simplex and keep updating with
new points - creating a 1-Simplex, then a 2-Simplex and so on, up to \(d\)-Simplex - until the process is finished.</p>

<p>Before my text get even more confuse lets take a look at some lines of code, considering the 2-dimensional case, to have a more general idea of the whole process.</p>

<pre><code class="language-cpp">bool testCollision(const ConvexPolygon&amp; a, const ConvexPolygon&amp; b) {
  // start with an arbitrarily direction for the support mapping
  vec2 d(1, 0);
  // simplex vertices (since it is 2D, we have at most 3 vertices)
  vec2 s[3];
  // number of vertices of the current simplex, initially an empty simplex
  int k = 0;
  while(1) {
    // sample a new point from the Minkowski difference set
    vec2 p = a.support(d) - b.support(-d);
    // check if the origin outside the set
    if(dot(p, d) &lt; 0)
      return false;
    // build and test the new simplex and compute the new direction d
    if(buildAndTestSimplex(s, p, k, d))
      return true;
  }
}
</code></pre>

<p>As you may notice, the code is quite simple (and it really is!). Each step we <em>jump</em> in the
direction of the origin to a new simplex of our set of simplicies that exists implicitly and look for the origin point (not exactly,
since there is more than one possible set of simplicies we are jumping between different simplicies of different sets&hellip; but that is not the focus here).
The real magic though, is inside <strong><code>buildAndTestSimplex</code></strong>, each step we need to decide what direction to take using the current simplex, here is
what happens:</p>

<h3 id="first-step-k-1"><strong>first step</strong> \(k = 1\)</h3>

<div class='block'>
  <p>First we start with a single point \(p\) of our \(A \ominus B\) set. There is not much to do here. The new direction to take is \(-\vec{op}\).</p>

<p><center><img align="middle" src="../../img/first.svg"   /></center></p>

</div>


<h3 id="second-step-k-2"><strong>second step</strong> \(k = 2\)</h3>

<div class='block'>
  <p>Now we have a 1-Simplex. As you can see, our plane is divided into 4 regions where the origin can be found. The first observation is that regions
<strong><span style="color:#ff8080;">1</span></strong> and <strong><span style="color:#ff8080;">4</span></strong>
don&rsquo;t contain the origin because the vertices were found by the support function in each direction of each of these regions, it means that
there are no more points of the \(A \ominus B\) set there. If the origin was in regions <strong><span style="color:#ff8080;">1</span></strong> or
<strong><span style="color:#ff8080;">4</span></strong> then the algorithm would had stopped at <strong><code>line 12</code></strong>.</p>

<p><center><img align="middle" src="../../img/second.svg"   /></center></p>

<p>So the origin is certainly in <strong><span style="color:#afe9af;">2</span></strong> or <strong><span style="color:#afdde9;">3</span></strong> and
the new direction is</p>

<p>$$v = \overline{S_0S_1}$$
$$
\begin{cases}
 &amp; \vec{d} = (-v_y, v_x), &amp; (v \times -S_0)_z &gt; 0 \<br />
 &amp; \vec{d} = (v_y, -v_x), &amp; (v \times -S_0)_z &lt; 0
\end{cases}
$$</p>

</div>


<h3 id="n-th-step-k-n-n-2">\(n^{th}\) <strong>step</strong> \(k = n, n &gt; 2\)</h3>

<div class='block'>
  <p>As the same case above, we observe our plane divided:</p>

<p><center><img align="middle" src="../../img/third.svg" alt="542px-four-level_z-svg"  /></center></p>

<p>If we keep the order of our vertices and use the same logic to exclude the regions <strong><span style="color:#ff8080;">1</span></strong> and <strong><span style="color:#ff8080;">4</span></strong> of the second step, then we can exclude regions <strong><span style="color:#ff8080;">1</span></strong>, <strong><span style="color:#ff8080;">2</span></strong>, <strong><span style="color:#ff8080;">3</span></strong> and <strong><span style="color:#ff8080;">7</span></strong>
of this step. To save some computations, we can verify first if the origin is in region <strong><span style="color:#afe9af;">5</span></strong> and <strong><span style="color:#5599ff;">6</span></strong>, and if is not then certainly is in region <strong><span style="color:#afdde9;">4</span></strong>.
<br>
Defining
$$v_{02} = \overline{S_0S_2}, v_{12} = \overline{S_1S_2}$$</p>

<p>If \((v_{02} \times -S_2)_z &gt; 0\) then the origin is in <strong><span style="color:#afe9af;">5</span></strong>
and the new direction is \((-v_{02_y}, v_{02_x})\).</p>

<p>If \((v_{12} \times -S_2)_z &lt; 0\) then the origin is in <strong><span style="color:#5599ff;">6</span></strong>
and the new direction is \((v_{12_y}, -v_{12_x})\).</p>

<p>Otherwise we return <strong>true</strong>.
<br>
<strong>Note:</strong> <em>remember to arrange the order of the vertices conveniently so these equations work properly.</em></p>

</div>


<p>Here is a very simple example of the algorithm in action:
<div id="myCanvasGJK"></div>
<script src="../../js/gjk.js" type="text/javascript"></script></p>

<p>The code:</p>

<pre><code class="language-cpp">// the z coordinate of the cross product of vectors (a.x, a.y, 0) and (b.x, b.y, 0)
float cross2D(const vec2&amp; a, const vec2&amp; b) {
  return a.x * b.y - a.y * b.x;
}
bool buildAndTestSimplex(vec2 s[], vec2 p, int &amp;k, vec2 &amp;d) {
  k = std::min(k + 1, 3);
  s[k - 1] = p;
  if(k == 1) {
    D = -s[0];
    return false;
  }
  if(k == 2) {
    vec2 a = s[1] - s[0];
    if(cross(a,-s[0]) &lt; 0) {
      s[2] = s[1];
      s[1] = s[0];
      s[0] = s[2];
      D = a.right();
    }
    else D = a.left();
    return false;
  }
  vec2 a = s[2] - s[0];
  if(cross(a, -s[0]) &gt; 0) {
    D = a.left();
    s[1] = s[2];
    k--;
    return false;
  }
  vec2 b = s[2] - s[1];
  if(cross(b, -s[1]) &lt; 0) {
    D = b.right();
    s[0] = s[2];
    k--;
    return false;
  }
  return true;
}
</code></pre>

<p>The 3D case follows the same idea, the difference is that in case \(k = 3\), we have to check which side of the triangle plane
the origin is and construct a tetrahedron. The cross products for the other cases must be adapted as well.</p>

    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Filipe CN</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2018-02-08</span>
  </p>
  
  
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/geometry/">geometry</a>
          
          <a href="/tags/programming/">programming</a>
          
          <a href="/tags/algorithm/">algorithm</a>
          
          <a href="/tags/hercules/">hercules</a>
          
        </div>

      
      <nav class="post-nav">
        
        
          <a class="next" href="/post/mcode/">
            <span class="next-text nav-default">Z-Order Curve</span>
            <span class="prev-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

  
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:filipedecn@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://twitter.com/fuiripecn" class="iconfont icon-twitter" title="twitter"></a>
      <a href="http://linkedin.com/in/filipe-cn-a869084a" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="https://plus.google.com/u/0/&#43;FilipeCN" class="iconfont icon-google" title="google"></a>
      <a href="http://github.com/filipecn" class="iconfont icon-github" title="github"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme -
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy;
    2018
    <span class="author">FilipeCN</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>
<script type="text/javascript" src="/dist/even.min.js?v=3.0.0"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      showProcessingMessages: false,
      messageStyle: 'none'
    });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-85882787-1', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>







</body>
</html>
