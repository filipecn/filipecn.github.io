<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>A path tracer with CUDA - prt 3 :: filipecn</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="What we have so far:
 The image will be rendered in the GPU in groups of tiles. Each tile covers a sub-region of the image with 16x16 pixels. (part 1) A set of rays is generated for each pixel. Each ray direction is based on a random sample of the pixel&amp;rsquo;s area. We pre-compute and store all samples with a SamplePoll structure. (part 2)  The next topic is the way we will handle our objects (scene objects, materials, lights, etc&amp;hellip;)." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="/post/ptracer-gpu3/" />




<link rel="stylesheet" href="/assets/style.css">






<link rel="apple-touch-icon" href="/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="/favicon.ico">



<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="A path tracer with CUDA - prt 3">
<meta property="og:description" content="Object handling avoiding polymorphism and a first render!" />
<meta property="og:url" content="/post/ptracer-gpu3/" />
<meta property="og:site_name" content="filipecn" />

  
    <meta property="og:image" content="/favicon.ico">
  

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2021-09-05 00:00:00 &#43;0000 UTC" />












<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>





<link rel="stylesheet" href="/publication_container.5744e18b41c64a2d3769f36cb2ca6ffbc84b1fbdc7c7b547c7230eb15dd61432.css">

<link rel="stylesheet" href="/css/projectcard.css">
<link rel="stylesheet" href="/css/smallprojectcard.css">
<link rel="stylesheet" href="/css/faicon.css">


<script src="/js/posts/polygon.js"></script> 
<script src="/js/posts/two.min.js"></script> 
<script src="https://code.jquery.com/jquery-1.9.1.js"></script>



</head>
<body class="orange">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    filipecn
  </div>
</a>

    </div>
    
      <div class="menu-trigger">menu</div>
    
  </div>

  <center>
<p></p>
  <strong> CS PhD canditate </strong> | filipedecn@gmail.com | <a href="https://github.com/filipecn">github</a> | <a href="https://www.linkedin.com/in/filipecn/">linkedin</a>
  </center>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/cv">CV</a></li>
        
      
        
          <li><a href="/projects">Projects</a></li>
        
      
        
          <li><a href="/publications">Publications</a></li>
        
      
        
          <li><a href="/post">Posts</a></li>
        
      
        
          <li><a href="/drawing">Drawing</a></li>
        
      
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/cv">CV</a></li>
      
    
      
        <li><a href="/projects">Projects</a></li>
      
    
      
        <li><a href="/publications">Publications</a></li>
      
    
      
        <li><a href="/post">Posts</a></li>
      
    
      
        <li><a href="/drawing">Drawing</a></li>
      
    
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/post/ptracer-gpu3/">A path tracer with CUDA - prt 3</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2021-09-05 
      </span>
    
    
  </div>

  
  <span class="post-tags">
    
    #<a href="/tags/rendering/">rendering</a>&nbsp;
    
    #<a href="/tags/gpu/">gpu</a>&nbsp;
    
  </span>
  

  

  
    <div class="table-of-contents">
      <h2>
        
          Table of Contents
        
      </h2>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#_c_-like-polymorphism"><em>C</em>-like polymorphism</a></li>
    <li><a href="#first-result">First Result</a></li>
    <li><a href="#notes">Notes</a></li>
  </ul>
</nav>
    </div>
  

  <div class="post-content"><div>
        <p><strong>What we have so far:</strong></p>
<ul>
<li>The image will be rendered in the GPU in groups of tiles. Each tile covers a sub-region of the image with 16x16 pixels. (<a href="/post/ptracer-gpu/">part 1</a>)</li>
<li>A set of rays is generated for each pixel. Each ray direction is based on a random sample of the pixel&rsquo;s area. We pre-compute and store all samples with a <code>SamplePoll</code> structure. (<a href="/post/ptracer-gpu2/">part 2</a>)</li>
</ul>
<p>The next topic is the way we will handle our objects (scene objects, materials, lights, etc&hellip;). Ray tracers are usually built on top of class hierarchies and PBRT is no different.
The core algorithm will test ray intersection against several types of objects (spheres, cubes, meshes, &hellip;) and polymorphism just fits in. However, I&rsquo;ll experiment something here: <strong>avoid polymorphism</strong>.</p>
<p>For no particular reason though. I could argue that I wanted to avoid the indirection caused by virtual methods, but I believe that as CUDA get new versions this kind of indirection would not be such an overhead. BUT let&rsquo;s see how a bunch of <code>if</code>s go.</p>
<blockquote>
<p>The idea is simple: There are no virtual methods on the base class anymore, the base class just holds the data common to its children and a pointer to the child. Children classes are assumed to provide the methods they are expected to do. During iteration, the pointer to the child is casted to the correct child type.</p>
</blockquote>
<h2 id="_c_-like-polymorphism"><em>C</em>-like polymorphism<a href="#_c_-like-polymorphism" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Let&rsquo;s get an actual example to make it more clear. The scene is composed by a set of scene objects of different shapes &ndash; spheres, boxes and meshes of triangles. Each shape in the scene has its own position, rotation and scale for example. So we can define a base structure for all shapes as so:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">enum</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ShapeType</span> {
  SPHERE,
  MESH,
  CUSTOM
};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Shape</span> {
  hermes<span style="color:#f92672">::</span>Transform o2w;                 <span style="color:#75715e">//!&lt; object space to world space transform
</span><span style="color:#75715e"></span>  hermes<span style="color:#f92672">::</span>Transform w2o;                 <span style="color:#75715e">//!&lt; world space to object space transform
</span><span style="color:#75715e"></span>  hermes<span style="color:#f92672">::</span>bbox3 bounds;                  <span style="color:#75715e">//!&lt; world space bounds
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>shape_data{<span style="color:#66d9ef">nullptr</span>};         <span style="color:#75715e">//!&lt; pointer to the child
</span><span style="color:#75715e"></span>  ShapeType type{ShapeType<span style="color:#f92672">::</span>CUSTOM};     <span style="color:#75715e">//!&lt; child type
</span><span style="color:#75715e"></span>  shape_flags flags{shape_flags<span style="color:#f92672">::</span>NONE};  <span style="color:#75715e">//!&lt; some useful flags
</span><span style="color:#75715e"></span>};
</code></pre></div><p>Now we can have a list of shapes <code>vector&lt;Shape&gt;</code> on which we can iterate and check ray intersection:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">vector<span style="color:#f92672">&lt;</span>Shape<span style="color:#f92672">&gt;</span> shapes;
<span style="color:#75715e">// iterate over shapes
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> shape : shapes) {
  <span style="color:#75715e">// check shape type
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">switch</span> (shape.type) {
    <span style="color:#66d9ef">case</span> ShapeType<span style="color:#f92672">::</span>SPHERE:
      <span style="color:#75715e">// cast pointer properly
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>Sphere<span style="color:#f92672">*&gt;</span>(shape.shape_data)<span style="color:#f92672">-&gt;</span>intersect(...);
      <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> ShapeType<span style="color:#f92672">::</span>MESH: ... <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> ShapeType<span style="color:#f92672">::</span>CUSTOM: ... <span style="color:#66d9ef">break</span>;
  }
}
</code></pre></div><blockquote>
<p>The same idea may be extended to template functions and classes.</p>
</blockquote>
<p>I&rsquo;ll use this design mostly in classes I judge to be more intensively accessed and iterated over.
In fact, everything that goes over the ray interaction with the scene will receive this same treatment.</p>
<p>Right now, I&rsquo;ve applied this logic to:</p>
<ul>
<li><strong>ray</strong>: The <code>RayDifferential</code> no longer inherits from <code>Ray</code>, but holds a <code>Ray</code> object in it.</li>
<li><strong>interaction</strong>: Same happens with <code>SurfaceInteraction</code>, that now holds an <code>Interaction</code> object in it.</li>
</ul>
<p>Also, <code>Material</code>, <code>Primitive</code>, <code>BSDF</code> and <code>BSSRDF</code> will be like this as well.</p>
<h2 id="first-result">First Result<a href="#first-result" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Putting all together we now have this general algorithm:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">device_vector<span style="color:#f92672">&lt;</span>Shapes<span style="color:#f92672">&gt;</span> shapes;
... <span style="color:#75715e">// setup scene with shapes and shape types
</span><span style="color:#75715e">// Subdivide image into tiles
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> tiles <span style="color:#f92672">=</span> generateTiles(image);
<span style="color:#75715e">// Subdivide tiles into tile groups (tiles of tiles)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> super_tiles <span style="color:#f92672">=</span> generateSuperTiles(tiles);
<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> super_tile : super_tiles) {
  StratifiedSampler sampler;
  ... <span style="color:#75715e">// pre-compute samples for tiles in super_tile
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// render on the gpu all tiles inside this super tile
</span><span style="color:#75715e"></span>  for_gpu_threads(<span style="color:#66d9ef">auto</span> tile : super_tile) {
    ... <span style="color:#75715e">// compute bounds for tile x0, y0 ...
</span><span style="color:#75715e"></span>    bounds2i tile_bounds({x0, y0}, {x1, y1});
    <span style="color:#66d9ef">auto</span> film_tile <span style="color:#f92672">=</span> film.getFilmTile(tile_bounds);
    <span style="color:#75715e">// loop over pixels in tile
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> ij : tile_bounds) {
        <span style="color:#75715e">// initiate sampler to generate the pixel samples
</span><span style="color:#75715e"></span>        sampler.startPixel(ij);
        <span style="color:#66d9ef">do</span> {
            <span style="color:#75715e">// retrieve pixel samples
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">auto</span> sample <span style="color:#f92672">=</span> sampler.sample(ij);
            <span style="color:#75715e">// compute camera ray
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">auto</span> ray <span style="color:#f92672">=</span> camera.generateRayDifferential(sample);
            <span style="color:#75715e">// traces ray through the scene and computes its radiance
</span><span style="color:#75715e"></span>            Spectrum L <span style="color:#f92672">=</span> scene.intersect(ray); <span style="color:#75715e">// iterate over shapes
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// register radiance into film tile
</span><span style="color:#75715e"></span>            film_tile.addSample(sample, L);
        } <span style="color:#66d9ef">while</span>(sampler.startNextSample());
    }
    <span style="color:#75715e">// store final film tile radiances into final film 
</span><span style="color:#75715e"></span>    film.mergeFilmTile(film_tile);
  }
}
</code></pre></div><p>It is actually a lot already :), but we are still in the basics. There is no shading yet. No materials or lights.
I only made the <code>Sphere</code> as the only available <code>Shape</code> type and its intersection returns the full radiance.
I set up the camera looking straight to the sphere and voilà! Our first render!</p>

  <img src="/img/posts/pbrt-cuda/render.png"  class="center"  />


<h2 id="notes">Notes<a href="#notes" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>Just a reminder of the <a href="https://github.com/filipecn/helios">link</a> of the source code.</li>
<li>There are other parts and details I had to implement in order to get the first render that I&rsquo;ve not mentioned. I&rsquo;ll only put the things that diverge most from the PBRT code for now.</li>
<li>There is no filtering going on in the film as well (just the box filter).</li>
</ul>
<blockquote>
<p>The <a href="/post/ptracer-gpu3/">next</a> post talks about &hellip; TODO: no next post yet :)</p>
</blockquote>

      </div></div>

  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2022 Powered by <a href="http://gohugo.io">Hugo</a></span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>








  
</div>

</body>
</html>
